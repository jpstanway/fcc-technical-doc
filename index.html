<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>FCC Technical Documentation</title>
        <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
        <link href="style.css" rel="stylesheet" type="text/css">
    </head>
    <body>
        <div id="container">
            <nav id="navbar">
                <header>
                    <h1>Technical Documentation</h1>
                </header>
                <ul id="main-menu">
                    <li><a href="#Introduction" class="nav-link">Introduction</a></li>
                    <li><a href="#How_To_Apply_CSS" class="nav-link">How to apply CSS</a></li>
                    <li><a href="#CSS_Syntax" class="nav-link">CSS syntax</a></li>
                    <li><a href="#CSS_Selectors" class="nav-link">CSS selectors</a></li>
                    <li><a href="#Simple_Selectors" class="nav-link">Simple selectors</a></li>
                    <li><a href="#Attribute_Selectors" class="nav-link">Attribute selectors</a></li>
                    <li><a href="#Pseudo-classes_And_Pseudo-elements" class="nav-link">Pseudo-classes and pseudo-elements</a></li>
                    <li><a href="#Combinators_And_Multiple_Selectors" class="nav-link">Combinators and multiple selectors</a></li>
                    <li><a href="#CSS_Values_And_Units" class="nav-link">CSS values and units</a></li>
                    <li><a href="#Cascade_And_Inheritance" class="nav-link">Cascade and inheritance</a></li>
                    <li><a href="#The_Box_Model" class="nav-link">The box model</a></li>
                    <li><a href="#Reference" class="nav-link">Reference</a></li>
                </ul>
            </nav>
            <main id="main-doc">
                <section id="Introduction" class="main-section">
                    <header>
                        <h2>Introduction</h2>
                    </header>
                    <p>CSS is a language used to specify how documents (web pages) are presented to users
                        in a visual manner. There are two main areas that it is used to affect web content:</p>
                    <ul>
                        <li><strong>style</strong> includes things like fonts, colors, borders, sizing, and even animations
                        for elements</li>
                        <li><strong>layout</strong> includes the spacing, position, and overall structure
                        of a page</li>
                    </ul>
                </section>
                <section id="How_To_Apply_CSS" class="main-section">
                    <header>
                        <h2>How to apply CSS</h2>
                    </header>
                    <p>There are three ways to apply CSS to your HTML document:</p>
                    <ol>
                        <li>
                            <p>Using an <strong>external stylesheet</strong> your CSS is written in a separate
                            file with a .css extension, and you reference it from your HTML file with a 
                            <code>&lt;link&gt;</code> element. This is the most common method for attaching CSS, and the most
                            recommended.</p>
                            <p>Here is an example HTML file:</p>
<code>
<pre>
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
        &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;My CSS experiment&lt;/title&gt;
        &lt;link rel="stylesheet" href="style.css"&gt;
        &lt;/head&gt;
        &lt;body&gt;
        &lt;h1&gt;Hello World!&lt;/h1&gt;
        &lt;p&gt;This is my first CSS example&lt;/p&gt;
        &lt;/body&gt;
    &lt;/html&gt;
</pre>
</code>
                            <p>And an external CSS file:</p>
<code>
<pre>
    h1 {
        color: blue;
        background-color: yellow;
        border: 1px solid black;
    }
          
    p {
        color: red;
    }
</pre>
</code>
                            
                        </li>
                        <li>
                            <p>Using an <strong>internal stylesheet</strong> is where you place your CSS inside a 
                            <code>&lt;style&gt;</code> element contained within the HTML <code>&lt;head&gt;</code>.</p>
                            <p>The HTML would look like this:</p>
<code>
<pre>  
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
        &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;My CSS experiment&lt;/title&gt;
        &lt;style&gt;
            h1 {
            color: blue;
            background-color: yellow;
            border: 1px solid black;
            }
            
            p {
            color: red;
            }
            
        &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
        &lt;h1&gt;Hello World!&lt;/h1&gt;
        &lt;p&gt;This is my first CSS example&lt;/p&gt;
        &lt;/body&gt;
    &lt;/html&gt;
</pre>      
</code>    
                            <p>This can be useful in some circumstances where you can't directly modify the CSS files,
                                but it isn't as efficient as using external stylesheets, because in a website, the css
                                would have to be repeated across every page and updated in multiple places if changes
                                were required.</p>
                        </li>
                        <li>
                        <p><strong>Inline styles</strong> are HTML attributes that affect only one element.</p> 
                        <p>Here is an example:</p>
<code>
<pre>
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
        &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;My CSS experiment&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
        &lt;h1 style="color: blue;background-color: yellow;border: 1px solid black;"&gt;Hello World!&lt;/h1&gt;
        &lt;p style="color:red;"&gt;This is my first CSS example&lt;/p&gt;
        &lt;/body&gt;
    &lt;/html&gt;
</pre>    
</code>
                        <p>
                            This is obviously the least desirable method for including CSS in your document, because
                            you'd have to update the same information multiple times, and it also mixes your
                            presentational CSS code with your structural HTML code, making it harder to read and understand.
                        </p>
                        </li>
                    </ol> 
                </section>
                <section id="CSS_Syntax" class="main-section">
                    <header>
                        <h2>CSS syntax</h2>
                    </header>
                    <p>In plain english, the basic structure of CSS is as follows - a CSS <em>rule or ruleset</em>
                     is paired with a <em>declaration block</em> which contains one or more <em>declarations</em>.</p>
                    <p>Breaking this down further:</p>
                    <ul>
                        <li><strong>rules/rulesets</strong> contain <em>selectors</em> that reference
                        the HTML element(s) you wish to style</li>
                        <li>a <strong>declaration</strong> is the pairing of a <em>property</em> (background,
                            color, font-size, etc.) and a <em>value</em> (the specific color, size, amount of
                            spacing, etc.)</li>
                        <li>the <strong>declaration block</strong> is a pair { } that contains all the declarations
                        for that CSS rule (stylings that will be applied to the HTML element(s))</li>
                    </ul>  
                    <p>Here is a visual representation of what that looks like:</p>
<code>
<pre>
    <em>rule/ruleset</em>
    selector(s)
    <em>declaration block</em>
    {
        <em>declarations</em>
        property1: value1;
        property2: value2;
        property3: value3;
    }
</pre>    
</code>
                    <p>And here is a more realistic view of the CSS syntax in action:</p>
<code>
<pre>
    h1 {
        colour: blue;
        background-color: yellow;
        border: 1px solid black;
    }
        
    p {
        color: red;
    }
        
    p, li {
        text-decoration: underline;
    }
</pre>
</code>
                </section>
                <section id="CSS_Selectors" class="main-section">
                    <header>
                        <h2>CSS Selectors</h2>
                    </header>
                    <p>There are 6 main categories for CSS selectors:</p>
                    <ul>
                        <li><strong>Simple selectors:</strong> match one or more elements based on element
                        type, class, or id</li>
                        <li><strong>Attribute selectors:</strong> match one or more elements based on their
                        attributes/attribute values</li>
                        <li><strong>Pseudo-classes:</strong> match one or more elements that exist in a certain state, 
                        such as an element that is being hovered over by the mouse pointer, or a checkbox that is 
                        currently disabled or checked, or an element that is the first child of its parent in the 
                        DOM tree</li>
                        <li><strong>Pseudo-elements:</strong> match one or more parts of content that are in a certain 
                        position in relation to an element, for example the first word of each paragraph, or generated 
                        content appearing just before an element</li>
                        <li><strong>Combinators:</strong> these are not exactly selectors themselves, but ways of combining 
                        two or more selectors in useful ways for very specific selections. So for example, you could select 
                        only paragraphs that are direct descendants of divs, or paragraphs that come directly after 
                        headings</li>
                        <li><strong>Multiple selectors:</strong> Again, these are not separate selectors; the idea is that 
                        you can put multiple selectors on the same CSS rule, separated by commas, to apply a single set of 
                        declarations to all the elements selected by those selectors</li>
                    </ul> 
                </section>
                <section id="Simple_Selectors" class="main-section">
                    <header>
                        <h2>Simple selectors</h2>
                    </header>
                    <p>First, we'll look at simple selectors. These are by far the most commonly used selectors.</p>
                    <p><strong>Type</strong> selectors, or <strong>element</strong> selectors simply refer to all HTML elements of that type. For example, 
                    all &lt;p&gt; elements would be selected with a simple 'p' as the selector, and all &lt;div&gt; elements 
                    with 'div':</p>
<code>
<pre>
p  {
    color: red;
}
    
div {
    width: 500px;
}
</pre>    
</code>
                <p>The <strong>ID</strong> selector consists of a hash/pound symbol (#), followed by the ID name of a given element. 
                Any element can have a unique ID name set with the id attribute. It is up to you to choose an ID name. 
                It's the most efficient way to select a single element.</p>
                <p>Here is some HTML showing elements with id attributes:</p>
<code>
<pre>
    &lt;p id="polite"&gt; — "Good morning."&lt;/p&gt;
    &lt;p id="rude"&gt; — "Go away!"&lt;/p&gt;
</pre>    
</code>
                <p>And the CSS to style them:</p>
<code>
<pre>
    #polite {
        font-family: cursive;
    }
        
    #rude {
        font-family: monospace;
        text-transform: uppercase;
    }
</pre>    
</code>
                <p><strong>Class</strong> selectors consist of a dot ('.') followed by the class name. A class name is any value, without 
                spaces, placed within an HTML class attribute. It is up to you to choose a name for the class. It is also 
                noteworthy that multiple elements in a document can have the same class value, and a single element can 
                have multiple class names separated by white space.</p>
                <p>Here are some HTML elements with classes assigned to them:</p>
<code>
<pre>
    &lt;ul&gt;
        &lt;li class="first done"&gt;Create an HTML document&lt;/li&gt;
        &lt;li class="second done"&gt;Create a CSS style sheet&lt;/li&gt;
        &lt;li class="third"&gt;Link them all together&lt;/li&gt;
    &lt;/ul&gt;
</pre>  
</code>
                <p>And how you'd style those with CSS:</p>
<code>
<pre>
    /* The element with the class "first" is bolded */
    .first {
        font-weight: bold;
    }
    
    /* All the elements with the class "done" are strike through */
    .done {
        text-decoration: line-through;
    }
</pre>    
</code>
                <p>As a bonus, another type of simple selector is the <strong>all</strong> selector, or a single '*'. 
                This selects all elements on the page.</p>
                <p>Here is a quick example:</p>
<code>
<pre>
    * {
        padding: 5px;
        border: 1px solid black;
        background: rgba(255,0,0,0.25)
    }
</pre>    
</code>                
                </section>
                <section id="Attribute_Selectors" class="main-section">
                    <header>
                        <h2>Attribute Selectors</h2>
                    </header>
                    <p><strong>Attribute selectors</strong> are a special kind of selector that will match
                    elements based on their HTML attributes and attribute values. Attribute selectors can be
                    divided into two categories depending on the way they match attribute values: <em>Presence
                    and value</em> attribute selectors and <em>Substring value</em> attribute selectors.</p>
                    <p>Here are some quick examples of <strong>presence and value</strong> attribute selectors:</p>
                    <ul>
                        <li><code>[attr]</code>: this selector will select all elements with the attribute
                        'attr', whatever its value</li>
                        <li><code>[attr=val]</code>: this selector will select all elements with the attribute
                        'attr', but only if its value equals 'val'</li>
                        <li><code>[attr~=val]</code>: this selector will select all elements with the attribute
                        'attr', but only if 'val' is one of a space-separated list of words contained in 'attr's value</li>
                    </ul>  
                    <p>Here is a visual representation of all 3 of these types:</p>
<code>
<pre>
    /* All elements with the attribute "data-vegetable"
        are given green text */
    [data-vegetable] {
        color: green;
    }

        /* All elements with the attribute "data-vegetable"
        with the exact value "liquid" are given a golden
        background color */
    [data-vegetable="liquid"] {
        background-color: goldenrod;
    }

    /* All elements with the attribute "data-vegetable",
        containing the value "spicy", even among others,
        are given a red text color */
    [data-vegetable~="spicy"] {
        color: red;
    }
</pre>
</code>
                <p><strong>Substring value</strong> attribute selectors are also known as "RegExp-like selectors",
                because they offer flexible matching in a similar fashion to regular expressions:</p>
                <ul>
                    <li><code>[attr|=val]</code>: this selector will select all elements with the attribute
                    'attr' for which the value is exactly 'val' or starts with 'val'</li>
                    <li><code>[attr^=val]</code>: this selector will select all elements with the attribute
                    'attr' for which the value starts with 'val'</li>
                    <li><code>[attr$=val]</code>: this selector will select all elements with the attribute
                    'attr' for which the value ends with 'val'</li>
                    <li><code>[attr*=val]</code>: this selector will select all elements with the attribute
                    'attr' for which the value contains the substring 'val' (A substring is simply part of a 
                    string, e.g. "cat" is a substring in the string "caterpillar".)</li>
                </ul>
                <p>Let's see an example of these types:</p>
<code>
<pre>
    /* Classic usage for language selection */
    [lang|="fr"] {
        font-weight: bold;
    }

    /* All elements with the attribute "data-quantity", for which
        the value starts with "optional" */
    [data-quantity^="optional"] {
        opacity: 0.5;
    }

    /* All elements with the attribute "data-quantity", for which
        the value ends with "kg" */
    [data-quantity$="kg"] {
        font-weight: bold;
    }

    /* All elements with the attribute "data-vegetable" containing
        the substring "not spicy" are turned back to green */
    [data-vegetable*="not spicy"] {
        color: green;
    }
</pre>
</code>
                </section>
                <section id="Pseudo-classes_And_Pseudo-elements" class="main-section">
                    <header>
                        <h2>Pseudo-classes and pseudo-elements</h2>
                    </header>
                    <p>These don't select elements, but rather certain parts of elements, 
                        or elements only in certain contexts.</p>
                    <p>A CSS <strong>pseudo-class</strong> is a keyword added to the end of a selector, preceded by a colon (:), 
                        which is used to specify that you want to style the selected element but only when it 
                        is in a certain state. </p>
                    <p>Example of pseudo-classes:</p>    
<code>
<pre>
    /* These styles will style our link
        in all states */
    a {
        color: blue;
        font-weight: bold;
    }
        
    /* We want visited links to be the same color
        as non visited links */
    a:visited {
        color: blue;
    }
        
    /* We highlight the link when it is
        hovered (mouse), activated
        or focused (keyboard) */
    a:hover,
    a:active,
    a:focus {
        color: darkred;
        text-decoration: none;
    }
</pre>
</code>
                    <p><strong>Pseudo-elements</strong> are very much like pseudo-classes, but they have differences. They are keywords, 
                        this time preceded by two colons (::), that can be added to the end of selectors to select a 
                        certain part of an element.</p>
                    <p>Pseudo-element example:</p>
<code>
<pre>
    /* All elements with an attribute "href" with values
        starting with "http" will have an arrow added after their
        content (to indicate they are external links) */
    [href^=http]::after {
        content: '⤴';
    } 
</pre>
</code>
                </section>
                <section id="Combinators_And_Multiple_Selectors" class="main-section">
                    <header>
                        <h2>Combinators and multiple selectors</h2>
                    </header>
                    <p>Using one selector at a time is useful, but can be inefficient in some situations. 
                        CSS selectors become even more useful when you start combining them to perform 
                        fine-grained selections. CSS has several ways to select elements based on how they 
                        are related to one another. Those relationships are expressed with <strong>combinators</strong> as 
                        follows (A and B represent any selector seen above):</p>
                    <table>
                        <thead>
                            <th>Name</th>
                            <th>Syntax</th>
                            <th>Selects</th>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Group of selectors</td>
                                <td>A, B</td>
                                <td>Any element matching A and/or B (see Group of selectors on one rule, below - 
                                    Group of Selectors is not considered to be a combinator).</td>
                            </tr>
                            <tr>
                                <td>Descendant selector</td>
                                <td>A B</td>
                                <td>Any element matching B that is a descendant of an element matching 
                                    A (that is, a child, or a child of a child, etc.).</td>
                            </tr>
                            <tr>
                                <td>Child selector</td>
                                <td>A > B</td>
                                <td>Any element matching B that is a direct child of an element matching A.</td>
                            </tr>
                            <tr>
                                <td>Adjacent sibling selector</td>
                                <td>A + B</td>
                                <td>Any element matching B that is the next sibling of an element matching A 
                                    (that is, the next child of the same parent).</td>
                            </tr>
                            <tr>
                                <td>General sibling selector</td>
                                <td>A ~ B</td>
                                <td>Any element matching B that is one of the next siblings of an element 
                                    matching A (that is, one of the next children of the same parent).</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Let's look at some examples:</p>
<code>
<pre>
    /* Basic table setup */
    table {
        font: 1em sans-serif;
        border-collapse: collapse;
        border-spacing: 0;
    }
    
    /* All &lt;td&gt;s within a &lt;table&gt; and all &lt;th&gt;s within a &lt;table&gt;
        Comma is not a combinator, it just allows you to target
        several selectors with the same CSS ruleset */
    table td, table th {
        border : 1px solid black;
        padding: 0.5em 0.5em 0.4em;
    }
    
    /* All &lt;th&gt;s within &lt;thead&gt;s that are within &lt;table&gt;s */
    table thead th {
        color: white;
        background: black;
    }
    
    /* All &lt;td&gt;s preceded by another &lt;td&gt;,
        within a &lt;tbody&gt;, within a &lt;table&gt; */
    table tbody td + td {
        text-align: center;
    }
    
    /* All &lt;td&gt;s that are a last child,
        within a &lt;tbody&gt;, within a &lt;table&gt; */
    table tbody td:last-child {
        text-align: right
    }
    
    /* All &lt;th&gt;s, within a &lt;tfoot&gt;s, within a &lt;table&gt; */
    table tfoot th {
        text-align: right;
        border-top-width: 5px;
        border-left: none;
        border-bottom: none;
    }
    
    /* All &lt;td&gt;s preceded by a &lt;th&gt;, within a &lt;table&gt; */
    table th + td {
        text-align: right;
        border-top-width: 5px;
        color: white;
        background: black;
    }
    
    /* All pseudo-elements "before" &lt;td&gt;s that are a last child,
        appearing within elements with a class of "with-currency" that
        also have an attribute "lang" with the value "en-US" */
    .with-currency[lang="en-US"] td:last-child::before {
        content: '$';
    }
    
    /* All pseudo-elements "after" &lt;td&gt;s that are a last child,
        appearing within elements with the class "with-currency" that
        also have an attribute "lang" with the value "fr" */
    .with-currency[lang="fr"] td:last-child::after {
        content: ' €';
    }
</pre>
</code>
                    <p>You have seen multiple examples of this in action already, 
                        but let's spell it out for clarification. You can write <strong>groups 
                        of selectors</strong> separated by commas to apply the same rule to multiple 
                        sets of selected elements at once. For example:</p>
<code>
<pre>
    p, li {
        font-size: 1.6em;
    }

    h1, h2, h3, h4, h5, h6 {
        font-family: helvetica, 'sans serif';
    }
</pre>
</code>    
                </section>
                <section id="CSS_Values_And_Units" class="main-section">
                    <header>
                        <h2>CSS values and units</h2>
                    </header>
                    <p>There are many value types in CSS, some of them very common and some of them that 
                        you'll rarely come across. We won't cover all of them exhaustively in this article; 
                        just the ones that you are likely to find most useful as you continue on your path 
                        towards mastering CSS. In this article we will cover the following CSS values:</p>
                    <ol>
                        <li>
                            <strong>Numeric values:</strong>
                            <p><em>Absolute units</em> will always be the same size regardless of any others
                            related settings. Absolute units are as follows:</p>
                            <ul>
                                <li><code>px</code>: pixels (most common)</li>
                                <li><code>mm</code>, <code>cm</code>, <code>in</code>: millimeters, centimeters, or inches</li>
                                <li><code>pt</code>, <code>pc</code>: points(1/72 of an inch) or picas (12 points)</li>
                            </ul>
                            <p><em>Relative units</em> are relative to the current element's font-size or viewport size:</p>
                            <ul>
                                <li><code>em</code>: 1em is the same as the font-size of the current element (more specifically, 
                                    the width of a capital letter M.) The default base font-size given to web pages by web 
                                    browsers before CSS styling is applied is 16 pixels, which means the computed value of 
                                    1em is 16 pixels for an element by default. But beware — font sizes are inherited by elements 
                                    from their parents, so if different font sizes have been set on parent elements, the pixel 
                                    equivalent of an em can start to become complicated. Don't worry too much about this for 
                                    now — we'll cover inheritance and font-sizing in more detail in later articles and modules. 
                                    <strong>ems are the most common relative unit you'll use in web development.</strong></li>
                                <li><code>ex</code>, <code>ch</code>: Respectively these are the height of a lower case x, 
                                    and the width of the number 0. These are not as commonly used or well-supported as ems.</li>
                                <li><code>rem</code>: The rem (root em) works in exactly the same way as the em, except that 
                                    it will always equal the size of the default base font-size; inherited font sizes will have 
                                    no effect, so this sounds like a much better option than ems, although rems don't work in 
                                    older versions of Internet Explorer.</li>
                                <li><code>vw</code>, <code>vh</code>: Respectively these are 1/100th of the width of the viewport, 
                                    and 1/100th of the height of the viewport. Again, these are not as widely supported as rems.</li>
                            </ul>
                            <p><em>Percentages</em>: You can also use percentage values to specify most things that can be specified 
                                by specific numeric values. This allows us to create, for example, boxes whose width will always shift 
                                to be a certain percentage of their parent container's width. This can be compared to boxes that have 
                                their width set to a certain unit value (like px or ems), which will always stay the same length, even 
                                if their parent container's width changes.</p>
                        </li>
                        <li>
                            <strong>Colors</strong>
                            <p>There are many ways to specify color in CSS, some of which are more recently implemented than others. 
                                The same color values can be used everywhere in CSS, whether you are specifying text color, background 
                                color, or whatever else.</p>
                            <p>The simplest, oldest color types in CSS are the color <strong>keywords</strong>. These are specific strings representing 
                                particular color values. For example, the following code:</p>
<code>
<pre>
    p {
        background-color: red;
    }
</pre>
</code>        
                        <p>The next ubiquitous color system is hexadecimal colors, or hex codes. Each hex value consists of a hash/pound symbol 
                            (#) followed by six hexadecimal numbers, each of which can take a value between 0 and f (which represents 15) 
                            — so 0123456789abcdef. Each pair of values represents one of the channels — red, green and blue — 
                            and allows us to specify any of the 256 available values for each (16 x 16 = 256.). So for example:</p>
<code>
<pre>
    /* equivalent to the red keyword */
    p:nth-child(1) {
        background-color: #ff0000;
    }
    
    /* equivalent to the blue keyword */
    p:nth-child(2) {
        background-color: #0000ff;
    }
    
    /* has no exact keyword equivalent */
    p:nth-child(3) {
        background-color: #e0b0ff;
    }
</pre>
</code>    
                        <p>The third scheme we'll talk about here is <strong>RGB</strong>. An RGB value is a function — rgb() — which is given three parameters 
                            that represent the red, green and blue channel values of the colors, in much the same way as hex values. 
                            The difference with RGB is that each channel is represented not by two hex digits, but by a decimal number between 0 and 255.
                            Let's rewrite our last example to use RGB colors:</p>
<code>
<pre>
    /* equivalent to the red keyword */
    p:nth-child(1) {
        background-color: rgb(255,0,0);
    }
    
    /* equivalent to the blue keyword */
    p:nth-child(2) {
        background-color: rgb(0,0,255);
    }
    
    /* has no exact keyword equivalent */
    p:nth-child(3) {
        background-color: rgb(224,176,255);
    }
</pre>
</code>                 <p>Slightly less well supported than RGB is the HSL model (not on old versions of IE), which was implemented after 
                            much interest from designers — instead of red, green and blue values, the hsl() function accepts hue, saturation, 
                            and lightness values, which are used to distinguish between the 16.7 million colors, but in a different way:</p>
                        <ul>
                            <li><em>hue:</em> the base shade of the color. This takes a value between 0 and 360, presenting the angles round a color wheel.</li>
                            <li><em>saturation:</em> how saturated is the color? This takes a value from 0-100%, where 0 is no color (it will appear as a shade of grey), 
                                and 100% is full color saturation</li>
                            <li><em>lightness:</em> how light or bright is the color? This takes a value from 0-100%, where 0 is no light (it will appear completely black) 
                                and 100% is full light (it will appear completely white)</li>
                        </ul>   
                        <p>Now we'll rewrite our example to use HSL colors:</p>
<code>
<pre>
    /* equivalent to the red keyword */
    p:nth-child(1) {
        background-color: hsl(0,100%,50%);
    }
    
    /* equivalent to the blue keyword */
    p:nth-child(2) {
        background-color: hsl(240,100%,50%);
    }
    
    /* has no exact keyword equivalent */
    p:nth-child(3) {
        background-color: hsl(276,100%,85%);
    }
</pre>
</code> 
                        <p>RGB and HSL both have corresponding modes — <strong>RGBA and HSLA</strong> — that allow you to set not only what 
                            color you want to display, but also what transparency you want that color to have. Their corresponding 
                            functions take the same parameters, plus a fourth value in the range 0–1 — which sets the transparency, 
                            or alpha channel. 0 is completely transparent, and 1 is completely opaque.</p>
                        <p>There is another way to specify transparency via CSS — the <strong>opacity</strong> property. Instead of setting the transparency of 
                            a particular color, this sets the transparency of all selected elements and their children. Again, let's study 
                            an example so we can see the difference. Now the CSS:</p>
<code>
<pre>
    /* Red with RGBA */
    p:nth-child(1) {
        background-color: rgba(255,0,0,0.5);
    }
    
    /* Red with opacity */
    p:nth-child(2) {
        background-color: rgb(255,0,0);
        opacity: 0.5;
    }
</pre>
</code>    
                        </li>
                    </ol>          
                </section>
                <section id="Cascade_And_Inheritance" class="main-section">
                    <header>
                        <h2>Cascade and inheritance</h2>
                    </header>
                    <h3>The cascade</h3>
                    <p>CSS is an acronym for Cascading Style Sheets, which indicates that the notion of the cascade 
                        is important. At its most basic level it indicates that the order of CSS rules matter, but 
                        it's more complex than that. What selectors win out in the cascade depends on three factors 
                        (these are listed in order of weight — earlier ones will overrule later ones):</p>
                    <ol>
                        <li>Importance</li>
                        <li>Specificity</li>
                        <li>Source order</li>
                    </ol>
                    <h4>Importance</h4>
                    <p>In CSS, there is a special piece of syntax you can use to make sure that a certain declaration 
                        will always win over all others: <strong>!important.</strong> Let's look at an example:</p>
<code>
<pre>
    #winning {
        background-color: red;
        border: 1px solid black;
    }
        
    .better {
        background-color: gray;
        border: none !important;
    }
        
    p {
        background-color: blue;
        color: white;
        padding: 5px;
    }
</pre>
</code>    
                    <p>Let's walk through this to see what's happening:</p>
                    <ol>
                        <li>You'll see that the third rule's color and padding values have been applied, 
                            but the background-color hasn't. Why? Really all three should surely apply, 
                            because rules later in the source order generally override earlier rules.</li>
                        <li>However, The rules above it win, because IDs/class selectors have higher 
                            specificity than element selectors (you'll learn more about this in the next section).</li> 
                        <li>Both elements have a class of better, but the 2nd one has an id of winning too. 
                            Since IDs have an even higher specificity than classes (you can only have one element 
                            with each unique ID on a page, but many elements with the same class — ID selectors 
                            are very specific in what they target), the red background color and the 1 pixel black 
                            border should both be applied to the 2nd element, with the first element getting the 
                            gray background color, and no border, as specified by the class.</li> 
                        <li>The 2nd element does get the red background color, but no border. Why? Because of the 
                            !important declaration in the second rule — including this after border: none means that 
                            this declaration will win over the border value in the previous rule, even though the 
                            ID has higher specificity.</li>          
                    </ol>
                    <h4>Specificity</h4>
                    <p>Specificity is basically a measure of how specific a selector is — how many elements it could match. 
                        As shown in the example seen above, element selectors have low specificity. Class selectors have 
                        a higher specificity, so will win against element selectors. ID selectors have an even higher 
                        specificity, so will win against class selectors. The only way to win against an ID selector is 
                        to use !important.</p>
                    <p>The amount of specificity a selector has is measured using four different values (or components), 
                        which can be thought of as thousands, hundreds, tens and ones — four single digits in four columns:</p>    
                    <ol>
                        <li><em>Thousands:</em> Score one in this column if the declaration is inside a style attribute (such declarations 
                            don't have selectors, so their specificity is always simply 1000.) Otherwise 0.</li>
                        <li><em>Hundreds:</em> Score one in this column for each ID selector contained inside the overall selector.</li>
                        <li><em>Tens:</em> Score one in this column for each class selector, attribute selector, or pseudo-class contained inside 
                            the overall selector.</li>
                        <li><em>Ones:</em> Score one in this column for each element selector or pseudo-element contained inside the overall selector.</li>
                    </ol>    
                    <p>Before we move on, let's look at an example in action. Here is the HTML we are going to use:</p>
<code>
<pre>
    /* specificity: 0101 */
    #outer a {
        background-color: red;
    }
    
    /* specificity: 0201 */
    #outer #inner a {
        background-color: blue;
    }
    
    /* specificity: 0104 */
    #outer div ul li a {
        color: yellow;
    }
    
    /* specificity: 0113 */
    #outer div ul .nav a {
        color: white;
    }
    
    /* specificity: 0024 */
    div div li:nth-child(2) a:hover {
        border: 10px solid black;
    }
    
    /* specificity: 0023 */
    div li:nth-child(2) a:hover {
        border: 10px dashed black;
    }
    
    /* specificity: 0033 */
    div div .nav:nth-child(2) a:hover {
        border: 10px double black;
    }
    
    a {
        display: inline-block;
        line-height: 40px;
        font-size: 20px;
        text-decoration: none;
        text-align: center;
        width: 200px;
        margin-bottom: 10px;
    }
    
    ul {
        padding: 0;
    }
    
    li {
        list-style-type: none;
    }
</pre>
</code>
                    <h4>Source order</h4>
                    <p>As mentioned above, if multiple competing selectors have the same importance and specificity, 
                        the third factor that comes into play to help decide which rule wins is source order — later 
                        rules will win over earlier rules. For example:</p>
<code>
<pre>
    p {
        color: blue;
    }
        
    /* This rule will win over the first one */
    p {
        color: red;
    }
</pre>
</code>    
                    <p>Whereas in this example the first rule wins because source order is overruled by specificity:</p>
<code>
<pre>
    /* This rule will win */
    .footnote {
        color: blue;
    }
    
    p {
        color: red;
    }
</pre>
</code>
                    <h3>Inheritance</h3>
                    <p>CSS inheritance is the last piece we need to investigate to get all the information and understand 
                        what style is applied to an element. The idea is that some property values applied to an element 
                        will be inherited by that element's children, and some won't.</p>
                    <p>CSS provides four special universal property values for specifying inheritance:</p>    
                    <ul>
                        <li><code>inherit</code>: Sets the property value applied to a selected element to be the same as 
                            that of its parent element.</li>
                        <li><code>initial</code>: Sets the property value applied to a selected element to be the same as 
                            the value set for that element in the browser's default style sheet. If no value is set by the 
                            browser's default style sheet and the property is naturally inherited, then the property value 
                            is set to inherit instead.</li>
                        <li><code>unset</code>: Resets the property to its natural value, which means that if the property 
                            is naturally inherited it acts like inherit, otherwise it acts like initial.</li>
                        <li><code>revert</code>: Reverts the property to the value it would have had if the current origin 
                            had not applied any styles to it. In other words, the property's value is set to the user 
                            stylesheet's value for the property (if one is set), otherwise the property's value is taken 
                            from the user-agent's default stylesheet.</li>
                    </ul>
                </section>
                <section id="The_Box_Model" class="main-section">
                        <header>
                            <h2>The box model</h2>
                        </header>
                        <p>Every element within a document is structured as a rectangular box inside the document layout, 
                            the size and "onion layers" of which can be tweaked using some specific CSS properties. 
                            The relevant properties are as follows:</p>
                        <ul>
                            <li><code>width</code> and <code>height</code>: The width and height properties set the width 
                                and height of the content box, which is the area in which the content of the box is displayed
                                 — this content includes both text content set inside the box, and other boxes representing 
                                 nested child elements.</li>
                            <li><code>padding</code>: Padding refers to the inner margin of a CSS box — between the outer edge 
                                of the content box and the inner edge of the border. The size of this layer can be set on all 
                                four sides at once with the padding shorthand property, or one side at a time with the padding-top, 
                                padding-right, padding-bottom and padding-left properties.</li>
                            <li><code>border</code>: The border of a CSS box sits between the outer edge of the padding and the inner 
                                edge of the margin. By default the border has a size of 0 — making it invisible — but you can set 
                                the thickness, style and color of the border to make it appear. The border shorthand property 
                                allows you to set all of these on all four sides at once, for example border: 1px solid black. 
                                This can be broken down into numerous different longhand properties for more specific styling 
                                needs:
                                <ul>
                                    <li>border-top, border-right, border-bottom, border-left: Set the thickness, style and color 
                                        of one side of the border.</li>
                                    <li>border-width, border-style, border-color: Set only the thickness, style, or color individually, 
                                        but for all four sides of the border.</li>
                                    <li>You can also set one of the three properties of a single side of the border individually, 
                                        using border-top-width, border-top-style, border-top-color, etc. </li>
                                </ul>
                            </li>
                            <li><code>margin</code>: The margin surrounds a CSS box, and pushes up against other CSS boxes in the 
                                layout. It behaves rather like padding; the shorthand property is margin and the individual properties 
                                are margin-top, margin-right, margin-bottom, and margin-left.</li>
                        </ul>    
                        <h3>Overflow</h3>
                        <p>When you set the size of a box with absolute values (e.g. a fixed pixel width/height), the content may not 
                            fit within the allowed size, in which case the content overflows the box. To control what happens in such 
                            cases, we can use the <strong>overflow</strong> property. It takes several possible values, but the most common are:</p>
                        <ul>
                            <li><code>auto</code>: If there is too much content, the overflowing content is hidden and scroll bars are shown to let 
                                the user scroll to see all the content.</li>
                            <li><code>hidden</code>: If there is too much content, the overflowing content is hidden.</li>
                            <li><code>visible</code>: If there is too much content, the overflowing content is shown outside of the box 
                                (this is usually the default behavior.)</li>
                        </ul>    
                        <h3>Types of CSS boxes</h3>
                        <p>Everything we've said so far applies to boxes that represent block level elements. However, CSS has other types of boxes 
                            that behave differently. The type of box applied to an element is specified by the display property. There are many 
                            different values available for display, but in this article we will focus on the three most common ones:</p>
                        <ul>
                            <li>A <strong>block</strong> box is defined as a box that's stacked upon other boxes (i.e. content before and after the box appears on a 
                                separate line), and can have width and height set on it. The whole box model as described above applies to block boxes.</li>
                            <li>An <strong>inline</strong> box is the opposite of a block box: it flows with the document's text (i.e. it will appear on the same line as surrounding 
                                text and other inline elements, and its content will break with the flow of the text, like lines of text in a paragraph.) Width and 
                                height settings have no effect on inline boxes; any padding, margin and border set on inline boxes will update the position of 
                                surrounding text, but will not affect the position of surrounding block boxes.</li>
                            <li>An <strong>inline-block</strong> box is something in between the first two: It flows with surrounding text and other inline elements without creating line 
                                breaks before and after it unlike a block box, but it can be sized using width and height and maintains its block integrity like a block box. 
                                It won't be broken across paragraph lines like an inline box. In the below example the inline-block box goes onto the 2nd line of text while 
                                keeping the shape of a box as there is not enough space for it on the first line, whereas inline box does break on multiple lines if there is 
                                not enough space — it loses the shape of a box.</li>
                        </ul>    
                    </section>
                    <section id="Reference" class="main-section">
                        <header>
                            <h2>Reference</h2>
                        </header>
                        <p>Everything in this document came from 
                            <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS" target="_blank">
                            MDN
                            </a>
                        </p>
            </main>
        </div>
    </body>
</html>